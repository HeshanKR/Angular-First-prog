My application is a angular frontend and express js + mysql backend. I want to create a application that lets user register using custom(name+ email+password) or google login, and login using custom account or google account. Following the roadmap you gave me to create this applcation before I deleted your memories to get more space. I was able to accomplish the following:

Full Roadmap: Secure Login System + Role-Based Access + Google Login
âœ… Youâ€™ve already done:
Angular + Tailwind CSS frontend âœ…

Express.js + MySQL backend âœ…

Backend APIs can send data to frontend âœ…

ğŸš€ Your End Goal:
ğŸ” User registration + login

ğŸ”‘ Google login

ğŸ§¾ JWT-based authentication

ğŸ”’ Protected routes and APIs

ğŸ‘¤ Role-based access (e.g., admin/user)

â˜ï¸ Secure deployment (future-proofing)

ğŸ”§ Roadmap (All Steps Youâ€™ll Complete)
ğŸ”¹ PHASE 1: Setup Secure Local Authentication
Step Task
âœ… 1 Set up users table with id, name, email, password, role
âœ… 2 Install backend packages (bcrypt, jsonwebtoken, express-validator, dotenv)
âœ… 3 Create /register and /login endpoints with validation and password hashing
âœ… 4 Generate and return JWT token on login (using cookies to store token, also we are not attaching it in request headers)
âœ… 5 Create /me route to return user info from token
âœ… 6 Create Express middleware to protect routes
âœ… 7 Create Angular AuthService to call backend, store token, track login state
âœ… 8 Create login and register forms in Angular
âœ… 9 Create Angular guards to restrict protected routes
âœ… 10 Hide UI elements (e.g., â€œAdmin Panelâ€) based on role

ğŸ”¹ PHASE 2: Add Role-Based Access
Step Task
âœ… 11 Update Express middleware to check userâ€™s role (e.g., isAdmin)
âœ… 12 Create admin-only endpoints (e.g., /admin/users)
âœ… 13 Use Angular guards to block UI/pages unless role matches
âœ… 14 Show/hide buttons/links based on role (\*ngIf="role === 'admin'")

ğŸ”¹ PHASE 3: Add Google Login
Step Task
âœ… 15 Set up a Google developer account + get OAuth 2.0 credentials
âœ… 16 Add a new backend route: GET /auth/google + callback using passport-google-oauth20
âœ… 17 Use Passport.js to verify Google token and create/fetch user in DB
âœ… 18 Return a JWT to frontend after successful Google login
âœ… 19 In Angular, add a â€œSign in with Googleâ€ button (can open popup or redirect)
âœ… 20 Store the JWT and log the user in just like local login

ğŸ”¹ PHASE 4: Add Security
Step Task
âœ… 21 rate limiting middleware to prevent abuse and validator to validate body data sent to the backend.
âœ… 22 Add Redis caching to store user sessions.

ğŸ”¹ PHASE 4: Security and Deployment (optional)
Step Task
â³ 21 Store JWT and .env secrets securely
â³ 22 Enable HTTPS for production
â³ 23 Add rate limiting or CAPTCHA to prevent abuse
â³ 24 Host backend (e.g., on Render, Railway) and frontend (e.g., Netlify, Vercel)

Below is folder and file structure of my angular frontend.

src/
â”œâ”€â”€ index.html  
â”œâ”€â”€ main.ts  
â”œâ”€â”€ style.css  
â””â”€â”€ app/
â”œâ”€â”€ app.ts  
 â”œâ”€â”€ app.routes.ts  
 â”œâ”€â”€ app.config.ts  
 â”œâ”€â”€ app.html  
 â”œâ”€â”€ app.css  
 â”œâ”€â”€ app.spec.ts
|--interceptors/
|--csrf.interceptors.ts
|--auth/
|--admin-guard.ts
|--user-guard.ts
|--google-login/
|--google-login.html
|--google-login.ts
|--services/
|--auth.service.ts
|--pages/
|--admin/
|--role-editor/
|--role-editor.css
|--role-editor.html
|--role-editor.ts
|--dashboard/
|--dashboard.component.css
|--dashboard.component.ts
|--dashboard.component.html
|--home/
|--home.css
|--home.html
|--home.ts
|--login/
|--login.component.css
|--login.component.html
|--login.component.ts
|--register/
|--register.component.ts
|--register.component.css
|--register.component.html

Below is my Express backend file and folder structure.

express-backend/
|--config/
|--passport-google.js
|--redisClient.js
|--controllers/
|--auth.controller.js
|--user.controller.js
|--db/
|--db.js
|--init.js
|--middlewares/
|--authMiddleware.js
|--rateLimiter.js
|--csrf.js
|--routes/
|--admin.routes.js
|--auth.routes.js
|--google-auth.routes.js
|--user.routes.js
|--index.js
|--.env

Google Auth Setup:

Perfect! Youâ€™ve done an excellent job getting through Phases 1 and 2. Now let's move on to **Phase 3: Add Google Login**.

---

### ğŸ”¹ Step 15: Set up a Google Developer Account + Get OAuth 2.0 Credentials

#### âœ… What You'll Do:

You'll create a Google project and obtain the credentials needed to allow users to log in with their Google accounts.

#### âœ… Step-by-Step:

1. **Go to the Google Developer Console:**
   [https://console.cloud.google.com/](https://console.cloud.google.com/)

2. **Create a New Project:**

   - Click the project dropdown (top left), then â€œNew Projectâ€.
   - Give it a name like `MahapolaAuthApp`.

3. **Enable OAuth Consent Screen:**

   - In the left sidebar, go to â€œOAuth consent screenâ€.
   - Choose â€œExternalâ€ (for public users) â†’ Click â€œCreateâ€.
   - Fill in the required fields (App name, User support email).
   - Add yourself as a test user (just your email).
   - Click â€œSave and Continueâ€ until done.

4. **Enable OAuth 2.0 API:**

   - Go to â€œAPIs & Servicesâ€ â†’ â€œLibraryâ€.
   - Search for â€œGoogle Identity Servicesâ€ or â€œGoogle+ APIâ€ and enable it.

5. **Create OAuth 2.0 Client ID:**

   - Go to â€œCredentialsâ€ â†’ â€œCreate Credentialsâ€ â†’ â€œOAuth Client IDâ€.
   - Choose â€œWeb Applicationâ€.
   - Set a name like `AngularAuthClient`.

   Under â€œAuthorized JavaScript originsâ€ add:

   ```
   http://localhost:4200
   ```

   Under â€œAuthorized redirect URIsâ€ add:

   ```
   http://localhost:3000/api/auth/google/callback
   ```

6. **Copy the Client ID and Client Secret** â€” weâ€™ll need them in Step 16.

Let me know when this step is done and Iâ€™ll walk you through configuring your backend (`passport-google-oauth20`) in Step 16.

Given your appâ€™s current state (Express + MySQL + Angular, JWT in **HTTP-only cookies**, no refresh tokens yet), Iâ€™d tackle those threats in this **priority order** so each step builds on the last:

1ï¸âƒ£ CSRF(Cross-Site Request Forgery)

Why first? Youâ€™re storing JWTs in cookies, which are automatically sent by the browser â€” this makes CSRF one of the most likely attacks on your app right now.

Mitigation:

- Implement a CSRF token system (`double-submit` or `synchronizer token pattern`).
- Or set `SameSite=Strict` (or `Lax`) on cookies to reduce cross-site requests.

2ï¸âƒ£ XSS Token Theft(Cross-Site Scripting)

Why second? Even though your JWT cookie is HTTP-only (good), XSS can still inject malicious scripts that make unauthorized API calls in the userâ€™s session.

Mitigation:

- Sanitize all user input.
- Use a CSP (Content Security Policy) to block inline scripts.
- Escape all dynamic HTML in Angular templates (Angular helps by default).

3ï¸âƒ£ Session Hijacking

Why now? Once CSRF & XSS are locked down, you still need to protect against attackers stealing or guessing session identifiers (cookies or tokens).

Mitigation:

- Use `Secure`, `HttpOnly`, `SameSite` on cookies.
- Rotate access tokens periodically.
- Invalidate sessions on logout or suspicious activity.

4ï¸âƒ£ Add Refresh Token Logic + Protect Against Stolen Refresh Token Abuse

Why here? Your app currently has no refresh tokens â€” adding them allows short-lived access tokens, which reduces impact of token theft.

Mitigation:

- Store refresh tokens securely in DB with IP/device binding.
- Rotate refresh tokens on every use (so stolen ones canâ€™t be reused).
- Add a server-side revocation list.

5ï¸âƒ£ Privilege Escalation

Why later? Itâ€™s less likely than token theft in your current setup, but critical for long-term security.

Mitigation:

- Enforce role-based access on _every_ backend route.
- Avoid relying solely on client-side role checks.
- Validate that role changes can only be made by authorized users.

6ï¸âƒ£ OAuth Token Forgery

Why next? Youâ€™re using Google OAuth â€” a forged token could let an attacker impersonate a user.
Mitigation:

- Always validate Google ID tokens with Googleâ€™s API or their public keys.
- Check `aud` (client ID), `iss` (issuer), and token expiry.

7ï¸âƒ£ MITM Attacks(Man-in-the-Middle)

Why last here? This is mostly about deployment/config â€” important, but your dev environment wonâ€™t benefit much until hosting.

Mitigation:

- Always use HTTPS in production.
- Set `Strict-Transport-Security` header.
- Avoid exposing tokens in query strings.

ğŸ“Œ Final Recommended Order for Your Project

1. CSRF protection (critical since JWT in cookies)âœ…
2. XSS hardening (block malicious script injection) + CSP âœ…
3. Session hijacking defenses (cookie settings, rotation)
4. Add refresh token system & abuse protection
5. Privilege escalation prevention (RBAC enforcement)âœ…
6. OAuth token forgery protection
7. MITM prevention (HTTPS, HSTS, secure deployment)

If you want, I can make you a security upgrade plan where each step is small, testable, and matches your codebase so you donâ€™t break anything mid-way. That way you can build protection one layer at a time instead of a big risky change.
